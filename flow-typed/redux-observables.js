/**
 * Flowtype definitions for te
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.3
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import type { Middleware, MiddlewareAPI, Action, Store } from "redux";
import {
  Observable,
  ObservableInput,
  Operator,
  SchedulerLike,
  Subject
} from "rxjs";

declare module "redux-observable" {
  declare export class ActionsObservable<T> mixins Observable<T> {
    /**
 * Just like RxJS itself, we can't actually make this method always type-safe
 * because we would need non-final position spread params e.g.
   `static of<T>(...items: T, scheduler?: Scheduler): ActionsObservable<T>`
which isn't possible in either JavaScript or TypeScript. So instead, we
provide safe typing for up to 6 items, following by a scheduler.
*/
    of<T>(item1: T, scheduler?: SchedulerLike): ActionsObservable<T>;
    of<T>(item1: T, item2: T, scheduler?: SchedulerLike): ActionsObservable<T>;
    of<T>(
      item1: T,
      item2: T,
      item3: T,
      scheduler?: SchedulerLike
    ): ActionsObservable<T>;
    of<T>(
      item1: T,
      item2: T,
      item3: T,
      item4: T,
      scheduler?: SchedulerLike
    ): ActionsObservable<T>;
    of<T>(
      item1: T,
      item2: T,
      item3: T,
      item4: T,
      item5: T,
      scheduler?: SchedulerLike
    ): ActionsObservable<T>;
    of<T>(
      item1: T,
      item2: T,
      item3: T,
      item4: T,
      item5: T,
      item6: T,
      scheduler?: SchedulerLike
    ): ActionsObservable<T>;
    of<T>(...array: Array<T | SchedulerLike>): ActionsObservable<T>;
    from<T>(
      ish: ObservableInput<T>,
      scheduler?: SchedulerLike
    ): ActionsObservable<T>;
    from<T, R>(ish: Array<T>, scheduler?: SchedulerLike): ActionsObservable<R>;
    constructor(input$: Observable<T>): this;
    lift<R>(operator: Operator<T, R>): ActionsObservable<R>;
    lift<R>(operator: Operator<T, R>): Observable<R>;
    ofType<R>(
      ...key: "NO PRINT IMPLEMENTED: IndexedAccessType"[]
    ): ActionsObservable<R>;
  }
  declare export class StateObservable<S> mixins Observable<S> {
    source: Subject<S>;
    constructor(stateSubject: Subject<S>, initialState: S): this;
    value: S;
  }
  declare export interface Epic<Input, Output, State, Dependencies> {
    (
      action$: ActionsObservable<Input>,
      state$: StateObservable<State>,
      dependencies: Dependencies
    ): Observable<Output>;
  }
  declare export type EpicMiddleware<T, O, S, D> = {
    run(rootEpic: Epic<T, O, S, D>): void
  } & Middleware;

  declare interface Options<D> {
    dependencies?: D;
  }
  declare export function createEpicMiddleware<T, O, S, D>(
    options?: Options<D>
  ): EpicMiddleware<T, O, S, D>;

  declare export function combineEpics<T, O, S, D>(
    ...epics: Epic<T, O, S, D>[]
  ): Epic<T, O, S, D>;

  declare export function ofType<T, R, K>(
    ...key: K[]
  ): (source: Observable<T>) => Observable<R>;
}
